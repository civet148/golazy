package gen

import (
	"fmt"
	"github.com/civet148/golazy/parser"
	"github.com/civet148/golazy/utils"
	"os"
	"path"
	"sort"
	"strings"
)

const (
	MethodGet     = "GET"
	MethodHead    = "HEAD"
	MethodPost    = "POST"
	MethodPut     = "PUT"
	MethodPatch   = "PATCH" // RFC 5789
	MethodDelete  = "DELETE"
	MethodConnect = "CONNECT"
	MethodOptions = "OPTIONS"
	MethodTrace   = "TRACE"
)

const (
	routesFilename = "routes"
	routesTemplate = `// Code generated by golazy. DO NOT EDIT.
package handler

import (
	"github.com/civet148/log"
	{{if .hasTimeout}}
	"time"{{end}}
	"github.com/gin-gonic/gin"
	{{.importPackages}}
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	_ "{{.rootPkg}}/docs" 
)


func RegisterHandlers(server *gin.Engine, serverCtx *svc.ServiceContext) {
	{{.routesAdditions}}
	// add swagger route handler
	if serverCtx.Config.Mode == "dev" {
		server.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
		log.Infof("swagger running at http://%s:%v/swagger/index.html", serverCtx.Config.Host, serverCtx.Config.Port)
	}
}
`
)

type (
	group struct {
		Prefix      string
		Middlewares []string
		Routes      []*route
	}
	route struct {
		Method  string
		Path    string
		Handler string
		Doc     string
	}
)

func genRoutes(cfg *Config, rootPkg string, apis []*parser.ApiService) error {
	var dir = cfg.OutDir
	//var builder strings.Builder
	routeFilename, err := utils.FileNamingFormat(cfg.Style, routesFilename)
	if err != nil {
		return err
	}
	routeFilename = routeFilename + ".go"
	filename := path.Join(dir, handlerDir, routeFilename)
	removeFile(filename)

	var hasMiddleware bool
	var groups []*group
	var imports []string
	var importMap = make(map[string]bool)
	for _, api := range apis {
		var g *group
		g, err = getGroupRoutes(api)
		if err != nil {
			return err
		}
		imp := genRouteImports(rootPkg, api)
		if len(imp) > 0 {
			ok := importMap[imp]
			if !ok {
				imports = append(imports, imp)
				importMap[imp] = true
			}
		}
		if len(g.Middlewares) != 0 {
			hasMiddleware = true
		}
		groups = append(groups, g)
	}
	if hasMiddleware {
		imports = append(imports, fmt.Sprintf("\"%s\"", utils.JoinPackages(rootPkg, middlewareDir)))
	}

	imports = append(imports, fmt.Sprintf("\"%s\"", utils.JoinPackages(rootPkg, contextDir)))
	strImports := strings.Join(imports, "\n\t")

	return genFile(fileGenConfig{
		dir:             dir,
		subdir:          handlerDir,
		filename:        routeFilename,
		templateName:    "routesTemplate",
		category:        category,
		builtinTemplate: routesTemplate,
		data: map[string]any{
			"hasTimeout":      false,
			"importPackages":  strImports,
			"rootPkg":         rootPkg,
			"routesAdditions": buildRoutesAdditions(rootPkg, groups),
		},
	})
}

func buildRoutesAdditions(rootPkg string, groups []*group) (builder string) {
	var routeGroups []*group
	//merge group routes and middlewares
	var routesMap = make(map[string]*group)
	for _, g := range groups {
		rg, ok := routesMap[g.Prefix]
		if !ok {
			rg = g
			routesMap[g.Prefix] = rg
			routeGroups = append(routeGroups, rg)
		} else {
			rg.Routes = append(rg.Routes, g.Routes...)
			rg.Middlewares = append(rg.Middlewares, g.Middlewares...)
		}
	}

	for _, rg := range routeGroups {
		handlerPkg := toPrefix(rg.Prefix)
		varGroup := "g" + handlerPkg
		//generate route group
		builder += fmt.Sprintf("%s := server.Group(\"%s\")\n", varGroup, rg.Prefix)

		//generate route group middlewares
		for _, m := range rg.Middlewares {
			builder += fmt.Sprintf("%s.Use(%s.New%sMiddleware().Handle())\n", varGroup, middlewarePacket, m)
		}
		builder += "{\n"
		//generate route path handler
		for _, r := range rg.Routes {
			builder += toHandleMethod(varGroup, handlerPkg, r)
		}
		builder += "}\n"
		builder += "\n"
	}
	return strings.TrimSpace(builder)
}

func genRouteImports(rootPkg string, api *parser.ApiService) string {
	folder := toFolder(api.Server.Prefix)
	importSet := utils.NewSet()
	//importSet.AddStr(fmt.Sprintf("\"%s\"", utils.JoinPackages(rootPkg, contextDir)))
	importSet.AddStr(fmt.Sprintf("%s \"%s\"", toPrefix(folder),
		utils.JoinPackages(rootPkg, handlerDir, folder)))
	imports := importSet.KeysStr()
	sort.Strings(imports)
	projectSection := strings.Join(imports, "\n\t")
	return fmt.Sprintf("%s\n\t", projectSection)
}

func toHandleMethod(varGroup, handlerPkg string, r *route) string {
	method := strings.ToUpper(r.Method)
	return fmt.Sprintf("%s.%s(\"%s\", %v.%sHandler(serverCtx))\n", varGroup, method, r.Path, handlerPkg, r.Handler)
}

func toFolder(prefix string) string {
	folder := prefix
	folder = strings.TrimPrefix(folder, "/")
	folder = strings.TrimSuffix(folder, "/")
	return folder
}

func getGroupRoutes(api *parser.ApiService) (*group, error) {
	middlewares := utils.GetMiddleware(api.Server)
	var g = &group{
		Routes:      nil,
		Middlewares: middlewares,
		Prefix:      api.Server.Prefix,
	}

	for _, a := range api.APIs {
		g.Routes = append(g.Routes, &route{
			Method:  a.Method,
			Path:    a.Path,
			Handler: a.Handler,
			Doc:     a.Doc,
		})
	}
	return g, nil
}

func toPrefix(folder string) string {
	return strings.ReplaceAll(folder, "/", "")
}

func removeFile(filename string) {
	err := os.Remove(filename)
	if err != nil {
		return
	}
}

func getRouterPath(api *parser.ApiService, spec *parser.ApiSpec) string {
	routerPath := fmt.Sprintf("%s%s", api.Server.Prefix, spec.Path)
	return routerPath
}
